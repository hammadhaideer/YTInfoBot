# -*- coding: utf-8 -*-
"""youtube_qa_app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/199pNEb2iFvreZKbY3bpJnIDr-qQu-a30
"""

!pip install youtube_transcript_api

!pip install langchain

!pip install langchain-community

!pip install -U langchain

from langchain_community.vectorstores import Qdrant

!pip install gradio

import os
import re
import time
import logging
from youtube_transcript_api import YouTubeTranscriptApi, TranscriptsDisabled
from langchain.chains import RetrievalQA
from langchain.text_splitter import CharacterTextSplitter
from langchain.prompts import PromptTemplate
from langchain.embeddings import HuggingFaceEmbeddings
import gradio as gr

# Set API key (if applicable)
# os.environ["OPENAI_API_KEY"] = "..."

# Function to get YouTube Transcript
def get_youtube_transcript(url, languages=['en']):
    """Fetches the transcript of a YouTube video in specified languages.

    Args:
        url (str): The URL of the YouTube video.
        languages (list): A list of language codes to request.

    Returns:
        str: The extracted transcript text or an error message.
    """

    video_id = re.search(r'(?<=v=)[^&#]+', url)
    if not video_id:
        video_id = re.search(r'youtu\.be/([^?&]+)', url)
    if video_id:
        video_id = video_id.group(1)
    else:
        raise ValueError("Invalid YouTube URL")

    try:
        transcript = YouTubeTranscriptApi.get_transcript(video_id, languages=languages)
        if not transcript:
            # Handle case where no transcript is found
            return f"No transcript available for the video in any of the requested languages: {languages}"
        transcript_text = " ".join([entry['text'] for entry in transcript])
        return transcript_text
    except TranscriptsDisabled:
        return "Transcript is disabled for this video."
    except Exception as e:
        logging.error(f"An error occurred: {str(e)}")
        return f"An error occurred: {str(e)}"

# Function to create QA System
def create_qa_system(transcript):
    """Creates a QA system using Langchain and Qdrant.

    Args:
        transcript (str): The extracted transcript text.

    Returns:
        tuple: A tuple containing the QA chain and split transcript documents.
    """

    prompt_template = """
    You are a helpful assistant. Answer the following question based on the provided text.

    Text:
    {text}

    Question:
    {question}
    """

    # Define prompt
    prompt = PromptTemplate(template=prompt_template, input_variables=['text', 'question'])

    # Split transcript into chunks
    text_splitter = CharacterTextSplitter(chunk_size=1000, chunk_overlap=200)
    split_texts = text_splitter.split_text(transcript)

    # Create embeddings and vector store with Qdrant
    embeddings = HuggingFaceEmbeddings(model_name="sentence-transformers/all-MiniLM-L6-v2")  # Use appropriate model
    qdrant_index = Qdrant.from_texts(split_texts, embeddings)

    # Create QA chain
    qa_chain = RetrievalQA.from_chain_type(
        retriever=qdrant_index.as_retriever(),
        prompt=prompt
    )

    return qa_chain, split_texts

# Function to answer a question
def answer_question(question, qa_chain, documents, retries=5):
    """Answers a question using the QA chain.

    Args:
        question (str): The question to be answered.
        qa_chain (RetrievalQA): The QA chain.
        documents (list): The split transcript documents.
        retries (int, optional): The number of retries in case of errors. Defaults to 5.

    Returns:
        str: The generated answer or an error message.
    """

    inputs = {
        'text': " ".join(documents),
        'question': question
    }

    for attempt in range(retries):
        try:
            result = qa_chain.run(inputs)
            return result
        except Exception as e:
            error_message = str(e)
            if "Rate limit" in error_message or "insufficient_quota" in error_message:
                logging.warning(f"Rate limit or quota error encountered. Attempt {attempt + 1} of {retries}.")
                wait_time = 2 ** attempt * 10  # Exponential backoff
                logging.info(f"Waiting for {wait_time} seconds...")
                time.sleep(wait_time)
            else:
                logging.error(f"An error occurred: {error_message}")
                return f"An error occurred: {error_message}"

    return "Failed to get a response after several attempts."

# Function to handle Gradio interface
def qa_app(youtube_url, question, languages=['en']):
    """Handles the Gradio interface interaction.

    Args:
        youtube_url (str): The YouTube URL.
        question (str): The user's question.
        languages (list): A list of preferred languages for the transcript.

    Returns:
        str: The generated answer or an error message.
    """

    transcript = get_youtube_transcript(youtube_url, languages=languages)
    if transcript == "No transcript available for the video in any of the requested languages: ['en']":
        return f"No transcript available for the video in any of the requested languages: {languages}"

    qa_chain, documents = create_qa_system(transcript)
    return answer_question(question, qa_chain, documents)

# Gradio interface
iface = gr.Interface(
    fn=qa_app,
    inputs=[
        gr.Textbox(label="YouTube URL"),
        gr.Textbox(label="Question"),
        gr.CheckboxGroup(label="Preferred Languages", choices=['en', 'fr', 'es', 'de', 'it', 'ru', 'ja', 'zh', 'ko', 'hi'])
    ],
    outputs="text",
    title="YouTube Question Answering App",
    description="Enter a YouTube URL and ask a question about the video content."
)

if __name__ == "__main__":
    iface.launch()